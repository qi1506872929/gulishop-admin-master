# day01

简洁版: https://github.com/PanJiaChen/vue-admin-template
加强版: https://github.com/PanJiaChen/vue-element-admin

## 一 先写登录和退出登录

1. 按照之前的思路先搞 login 静态页面
   找到 views 当中 login 组件
   修改登录二字
   添加背景图片
   配置路由(路由当中已经配置好登录的路由了)
   使用的话，是通过编程式导航在前置守卫当中自动使用的，不需要关心

2. 删除不需要的东西
   删除 api 里面不需要的
   删除路由当中不需要的
   删除 views 当中不需要的
   不用删除 store 当中的

3. 完成 login 页面验证规则的修改
   完成输入的用户名和密码的验证规则修改

4. 修改 axios 二次封装文件
   添加 token 需要修改
   X-Token 改为 token
   请求成功里面的 code 需要添加不等于 200 的情况，if (res. code !== 20000 && res. code !== 200)要警告

5. 修改代理
   禁用 mock 数据
   添加代理

6. 修改 api 接口 user 当中登录相关请求函数的接口为真实接口
   只需要把 url 改过来即可

7. 修改 store 当中用户登录、token 校验和退出相关的代码
   其实代码可以什么都不动，但是要看懂

8. 在 login 界面当中发请求(这里不需要修改，已经写好了)

9. 把 nav 当中右侧下拉当中改为首页和退出登录

## 二、(product)书写品牌(trademark)、属性(attr)、spu、sku (从头开始练习增删改查功能)

1. 所有的商品相关路由组件三大步(定义 注册(先常量注册，后面需要修改) 使用)
   > 商品管理 el-icon-s-shop 品牌管理 平台属性管理 SPU 管理 SKU 管理
   ```js
   // 配置商品管理相关的路由
   {
    path: '/product',
    component: Layout,
    name: 'Product',
    redirect: '/product/trademark/list',
    meta: { title: '商品管理', icon: 'el-icon-s-shop' },
    children: [
      {
        path: 'trademark/list',
        component: () => import('@/views/product/trademark/List'),
        name: 'Trademark',
        meta: { title: '品牌管理' }
      },
      {
        path: 'attr/list',
        component: () => import('@/views/product/attr/List'),
        name: 'Attr',
        meta: { title: '平台属性管理' }
      },
      {
        path: 'spu/list',
        component: () => import('@/views/product/spu/List'),
        name: 'Spu',
        meta: { title: 'SPU管理' }
      },
      {
        path: 'sku/list',
        component: () => import('@/views/product/sku/List'),
        name: 'Sku',
        meta: { title: 'SKU管理' }
      }
    ]
   },
   ```
2. 和之前的一样

3. 补充跨域

   - 跨域:
     1. - 是什么 你的目标和你自己现在的位置一样还是不一样 浏览器上的同源策略
        - 特点:
          1、跨域只存在于浏览器
          2、不在浏览器发请求是不会存在跨域问题的
          3、http 请求分为两大类: 普通 http 请求（刷新页面）和 ajax 请求（跨域是出现在 ajax 请求，并且不会刷新页面）
     2. 在什么地方 浏览器会跨域 服务器不会
     3. 什么条件会跨域
        同源(协议 ip 端口一致) 不跨域
        不同源就跨域(三个中间有一个不一样就跨域)
        http://localhost:8080/ -------》github
     4. 解决跨域:前端可以解决、后端解决。一般后端解决比前端解决容易
   - 配置代理服务器解决跨域 本质是把浏览器往服务器发请求转化为服务器往服务器发请求
     1. 本身我们现在就跑在开发服务器 webpack-dev-server
        而这个服务器带了一个模块，这个模块可以支持我们使用代理
     2. 原理: 在浏览器发请求的时候，把这个请求发给服务器上的这个代理模块
        再由这个代理模块转发给我们真正的服务器
        这样的话，我们原来由浏览器直接发送请求到服务器就转化为服务器到服务器之间的请求
     3. 你要让代理转发，那么得告诉代理你的这个请求什么情况需要转发
        配置以固定什么开头的路径需要代理转发，代理看到这个路径是以它开头就会帮你转发
     4. 代理转发的时候会把路径交给真正的请求服务器，作为请求路径，需要把固定的开头去除
     5. changeOrigin: true，//支持跨域，如果协议/主机也不相同，必须加上
        ```js
        proxy: {
         "/api": {
           target: "http://localhost:4000",
           pathRewrite: {"^/api": ""},
           changeOrigin: true
         }
        }
        ```

# day02

## 三、品牌管理增删改查业务逻辑

1. 需要修改面包屑当中第一项显示的默认值(把英文改为中文'首页') layout -> breadcrumb -> components/breadcrumb -> 首页
   整体列表界面显示的内边距 styles 里面的 index.scss app-container 类改为 app-main (10px)

2. 列表页(查)
   1、先搞静态页面参考已完成的页面自己去使用 element-ui 去搭

   - table 写法
     > 先写 eltable 回车有几列就复制几个列
     > 先把动态数据属性 data 干掉
     > 有边框得添加 table 的 border 属性每个列的 width 控制列的宽度
     > 每个列的 label 控制这个列的名称
     > 想让那个列居中，那么哪个列需要添加 align = "center" 那个列是序号，需要添加 type = "index"
   - pagination 写法
     > 关注怎么居中，需要添加 style = "text-align: center"
     > 中间缝隙 20px 给 table 添加上下外边距 20px

   2、再搞动态页面

   - api 写法
     es 模块化的复习
   - 请求获取数据
   - 展示数据 注意 table 展示数据的东西

3. 增加

   1. 实现静态页面 dialog 嵌套 form 表单

   - dialog 有一个动态的数据决定 dialog 的显式和隐藏（布尔值） :visible.sync
   - form 当中 :model=对象 指定收集的数据最终放在哪
   - form-item 当中 是收集数据的每一项 每一项都可以有 label 指定这一项名称，label-width="100px"指定名称的宽度
     每一项当中都可以对应收集数据，收集的数据一般都是放在我们指定的对象当中
   - upload 我们拷贝官方网站的上传头像那个，html css js 都要拷贝过来

   2. 实现添加动态交互和数据收集

   - 点击添加按钮实现 添加的对话框显示
   - 收集数据到指定的地方
     收集 input 的数据 tmName，这个已经可以收集了，v-model
     收集 upload 的数据 logoUrl 这个数据收集需要看拷贝过来的那些东西
     先请求上传到后端 后端返回真实路径 前端收集返回的真实路径
   - 添加收集完数据之后，没有确定发请求，而是点击取消，再次点击添加数据依然存在，这个 bug 需要解决
     就是点击添加按钮弹出 dialog 的时候，要把原本的 tmForm 当中的数据清空一下

4. 修改

   1. 实现修改的静态页面，和添加的页面共用同一个，不需要写
   2. 实现修改动态交互和数据收集
      点击修改按钮实现，修改的对话框显示（其实是同一个)，只是这次要带上相应的数据进行初始化展示
      收集数据在添加当中已经搞定，不需要再次写收集功能
      修改数据直接把 row 赋值给 tmform，会影响显示的数据，因此需要使用拷贝解决，让 row 和 tmform 不能指向同一个地址

5. 点击确定发请求添加或者修改 点击确定按钮去发请求添加品牌或者修改品牌

   1. 获取收集好的参数数据
   2. 整理收集好的参数数据
   3. 发送请求
   4. 成功干啥
   5. 失败干啥

6. 删除
   使用的是 messageBox 做的，带确认的那个
   在点击确定的逻辑当中，我们需要发请求删除
   成功需要提示，然后重新获取数据（是获取哪页的要根据数据条数来决定)失败提示就好了

7. rules

# day03

## 四、平台属性管理增删改查业务逻辑

1. 平台属性相关的 api 接口请求函数
2. 实现我们的页面功能 两个 el-card 上面的 card 放的是三级分类组件，下面的 card 还没开始做
3. CategorySelector 全局组件的静态实现
   根据官网 form 当中的行内 form 修改
4. CategorySelector 全局组件的动态实现
   写三级分类接口请求函数
   一上来第一个分类就要有数据，所以我们要 mouted 发请求拿数据给第一项分类去遍历展示数据选中了第一项当中的某个分类，才会发请求拿第二项的数据进行遍历展示
   选中了第二项当中的某个分类，才会发请求拿第三项的数据进行遍历展示选中第一项需要清空第 2、3 项的数据
   选中第二项需要清空第三项的数据
   选中 1、2、3 项都要和父组件通信，把 id 传递到父组件当中

   父组件当中判断 level 保存三个 id
   在父组件获取子组件传递过来的数据，保存 3 级 id 的时候需要发请求获取属性数据
   在父组件获取子组件传递过来的数据，保存 1 级 id 的时候需要清空父组件的 2、3 级 id 及属性列表数据在父组件获取子组件传递过来的数据，保存 2 级 id 的时候需要清空父组件的 3 级 id 及属性列表数据

5. 属性列表页（查)
   属性列表的静态页面实现 一个按钮和一个 table
   属性列表的动态实现 动态数据已经可以获取到

   展示属性列表数据

   展示 table 数据的时候注意展示属性值列表那项，数据结构要清楚，使用的是 vfor 和作用域插槽最后展示操作的按钮，使用的是之前封装的 HintButton，把之前的 a 标签改为 el-tooltip

6. 属性的增

   1. 实现增加属性的静态页面
      - 增加属性的静态页面和修改是一样的
      - 增加属性的静态页面和列表页都是在第二个 card 当中，但是同时只能显示一个
        用两个 div，一个 div 包含列表页相关的，另外一个包含添加和修改的页面
        定义数据 isShowList 控制 card 当中显示的是哪一个 必须使用 v-show
      - 增加属性的静态页面包含 一个行内 form 两个按钮 一个 table 两个按钮
   2. 实现增加属性页面的动态交互（点击按钮切换 确定按钮和取消按钮)
      点击列表页面的添加属性按钮，切换到添加页面，就是把 isShowList 改为 false
      点击添加页面的取消按钮，再切换回到列表页面，就是把 isShowList 改为 true
      完成列表页添加属性按钮和添加页面的添加属性值按钮的可操作性 disabled
   3. 实现增加属性动态收集数据
      - 收集属性名称 已经做到了，因为我们使用的是 v-model
      - 收集属性值列表:
        添加属性的属性值列表，一上来是一个空数组
        我们使用 table 在展示我们的属性值列表，但是一上来我们没有属性值，所以 table 里面没数据
        当我们添加属性值的时候
        > 1. 我们是在属性值的列表（数组）当中添加一个属性值对象，只不过这个属性值对象所有的属性为空
        >    只是为了让 table 当中出现一行（一个输入框），占位用的
        > 2. 当出现了输入框之后，用户是要去输入新添的属性值名称，当用户输入了以后，我们才真正的收集到
        >    刚才添加的属性值对象当中，形成真正的属性值对象
        > 3. 当用户失去焦点或者回车的时候，这个属性值对象才算完成收集
        > 4. 当用户添加完成，点击取消再次点击添加原来的数据还在的 bug 以及用户收集剩余的 categoryId 和 categoryLevel
        >    当用户点击添加按钮的时候，清空收集的对象，同时收集剩余的 categoryId 和 categoryLevel

7. 属性的修改
   1. 实现属性修改的静态页面
      和属性的添加用的是同一个静态页面，不需要再去写
   2. 实现修改属性动态交互
      点击修改按钮，切换到修改的页面，并且把当前的数据 row 带上
   3. 实现修改属性数据收集
      和属性添加收集是一样的，不需要再写

# day04

8. 属性值的模式添加(添加属性和修改属性是一样的)
   1. 一个属性值要不是新添加的，要不是已经存在的，新添加属性值显示 input，已经存在的属性值显示 span，而且可以切换，证明每个属性值都有两个模式，这两个模式叫编辑模式和查看模式
   2. 给每个属性值对象添加模式标识数据，用于确定这个属性值当前是 input 还是 span
      对于添加每个属性值的时候，都添加一个属性 isEdit: true, 代表添加的属性值是编辑模式
      在修改属性的时候，遍历每个已有的属性值对象都添加一个属性 isEdit = false, 这里必须使用 `$set` 才能响应式
      上面我们的表格当中不能直接写死是一个 input，每个属性值根据 isEdit 决定是 input 还是 span 使 用 v-if
9. 属性值模式的切换
   1. 在 input 上我们需要添加失去焦点和回车事件，切换为查看模式，本质就是修改 isEdit 属性值.
      input 在切换为 span 之前要判断数据合法性 toLook toEdit
      1、数据是不是空的
      2、除了自己以外，输入的数据是不是和其它的属性值名称重复
   2. 在 span 上我们需要添加点击事件，切换为编辑模式，本质就是修改 isEdit 属性值
10. 解决 input 输入框大的问题、span 点击区域过小的问题、自动获取焦点的问题
    1. 解决 input 输入框大的问题直 接添加 size = "mini"
    2. span 点击区域过小的问题 直接把 span 变为 block 宽 高 100%
    3. 自动获取焦点的问题
    - 什么时候要自动获取焦点
      1、添加新属性值的时候
      2、从 span 变为 input 的时候
    - 上面的 html el-input 需要添加 ref ref 的值是 各自的下标 `$index`
    - 在 toEdit 当中，添加自动获取焦点的逻辑
      ```js
      this.$nextTick(() => {
        this.$refs[index].focus();
      });
      ```
    - 在 addAttrValue 当中，添加自动获取焦点的逻辑
      ```js
      this.$nextTick(() => {
        this.$refs[this.attrForm.attrValueList.length - 1].focus();
      });
      ```
    - `this.$nextTick` 的使用(等待最近一次更新页面完成再执行)，必须要会
11. 删除属性值的操作
    删除属性值不是删除属性，不需要发请求，只需要从 attrForm.attrValueList 把对应的属性值对象删除就好了
    用到气泡确认框，用法参考官网
    气泡确认框点击确定按钮的事件名称叫 onConfirm 不是 confirm 官 网写错了
12. 保存属性操作
    1. 点击保存按钮，书写回调
    2. 获取收集的参数 attrForm
    3. 整理参数:
       1、属性值名称如果为空串，从属性值列表当中去除
       2、属性值当中去除 isEdit 属性
       3、属性值列表如果没有属性值，不发请求
    4. 发请求
       成功 提示 返回列表 重新获取数据
       失败 提示
13. 删除属性
    点击列表页删除按钮删除属性
    发请求
    成功 提示 重新获取数据
    失败 提示
14. 处理保存按钮的可操作性
    属性值列表如果是空，不能点击保存
15. 处理三级联动的可操作性
    三级分类的可操作性，CategorySelector 内部的 form 也可以使用 disabled
    disabled 的值恰好和父组件的 isShowList 是相反的
    父组件传递 isShowList 给 CategorySelector，内部 form 的 :disabled= "!isShowList"

## 五、SPU 管理增删改查业务逻辑

1. spu 功能演示，看看功能
2. spu 和 sku 平台属性和销售属性的概念理解
3. spu 页面 三级联动
   1. 整个页面和属性页面类似，也是两个 card 形成 3d 效果
   2. 第一个 card 里面是，组件 CategorySelector.第二个 card 里面是列表页
   3. CategorySeleotor 组件已经是做好的组件，内部需要父组件定义的数据都要定义
   4. CategorySelector 组件已经是做好的组件，内部需要父组件定义的事件也得定义 changeCategory
      changeCategory 的回调当中和属性类似、注意保存 3 级类别 id 后需要发请求获取 spu 的分页列表
4. spu 列表页的实现
   1. 静态页面实现比属性页面多了一个分页器
   2. 动态数据展示
   3. 实现三个页面在第二个 card 里面的切换
      列表页 添加或修改 spu 的页面 添加 sku 的页面 三个页面共享第二个 card，同时只能显示一个
      列表页在一个 div
      剩余的两个页面做成 2 个组件 SpuForm 和 SkuForm
      data 当中设计两个数据 isShowSpuForm 和 isShowSkuForm 控制三个页面的显示和隐藏切换
   4. 对三个按钮添加点击事件达成三个页面之间的切换
5. 修改 spu
   1. 点击修改 spu 要显示 SpuForm 子组件
   2. 搭建修改 spu 和添加 spu 的静态页面
   3. 在显示 SpuForm 的时候需要发送 4 个请求获取初始化数据
   4. 在父组件当中通过 `$ref` 获取到子组件对象，调用子组件对象的一个方法，在这个方法当中去发 4 个请求
      - 4 个请求要分析清楚，分别请求的是什么
      - 发请求获取 4 个数据，保存，保存在哪里要注意
   5. 点击取消使用. sync 返回到列表页
   6. 将获取到的动态数据初始化展示
      - 前三项都是通过 v-model 直接展示的，注意品牌 option 需要做 v-for
      - spu 图片列表的展示，需要在请求获取到图片列表的时候，处理一下，列表当中每个图片对象都要有 name 和 url 属性
        展示使用的是 upload 照片墙，需要把获取到的数据列表给 upload 的 file-list 属性
   7. 展示销售属性
      - 展示 spu 自己的销售属性，在 table 当中展示
        这里面也用到了 el-tag
        这次的 el-tag 和平台属性不同，带关闭的标签
        这里面也有编辑模式和查看模式，只是这次编辑模式和查看模式每个属性只有一个，而不是每个属性值都有 input 
        里面的 v-if 和 v-model 数据都是挂在当前属性身上的
      - 展示所有的销售属性，但是除去自己，剩余的销售属性
        需要根据已有的销售属性列表和所有的销售属性列表计算出未使用的销售属性
        方法的嵌套用法 filter 嵌套 every
   8. 收集数据
      - 前三个已经收集完成 spuName 描述 tmId
      - 收集图片列表
        - 1、把接口换成真实接口
        - 2、照片墙收集的时候，删除成功要收集，添加成功也要收集，都要把最新的图片列表收集起来
          `:on-preview="handlePictureCardPreview"` 预览大图．不需要写，别人已经完成
          `:on-remove="handleRemove'` 删除图片成功的回调，内部要收集图片列表
          `:on-success="handleSuccess"` 添加图片成功的回调，内部也要收集图片列表
        - 3、注意 如果新上传了图片，那么新上传的图片和老的图片内部属性是不一样的
          新的图片内部没有 imgName 和 imgUrl 但是有 name 和 url，只是 url 是本地路径，错的
          老的图片内部既有 imgName 和 imgUrl 也有 name 和 url 都是对的
   9. 收集销售属性
      - 添加销售属性
        - 添加销售属性就是从未使用的销售属性列表中，往 spu 自己的销售属性列表添加一个
        - 1、添加到哪 spuForm.spuSaleAttrList
        - 2、添加的结构是什么
          ```js
          {
            baseSaleAttrId: 0,
            saleAttrName: "string",
            spuSaleAttrValueList: [],
          },
          ```
        - 3、收集什么
          选中的未使用的销售属性的 baseSaleAttrId 和 saleAttrName 收集到 data 中
        - 4. 添加销售属性的按钮可操作性处理，就看手机的数据当中有没有值，没有值就不能操作
        - 收集的过程
          1. 选中 select 某个项的时候，收集选中的那一项的 baseSaleAttrId 和 saleAttrName，拼接 data
          2. 当点击添加销售属性按钮的时候，在回调函数当中获取刚才收集到的 data 当中的数据把这个数据构造成要添加的对象解构
          3. 把这个对象添加到指定的位置 spuForm.spuSaleAttrList
          4. 将收集到的数据清空
   10. 添加销售属性值
       - 1、添加到哪
         添加到 spu 自己的销售属性当中销售属性值列表里面
         就是 table 当中 row.spuSaleAttrValueList
       - 2、添加的结构是啥﹑最后只需要销售属性值名称就可以了，其余都是多余的，删除掉
       - 3、收集什么
         saleAttrValueName baseSaleAttrId
       - 收集的过程:
         1. 点击添加按钮，让 button 变为 input，顺便自动获取焦点 就是让 row.inputVisible 为 true，要用 `$set`
         2. 输入属性值名称，并且同时就通过 v-model 把输入的数据保存在了 row 身上
         3. 失去焦点或者回车之后，在回调函数当中，把收集到的数据，构造成想要的结构
         4. 把构造成的结构对象添加到 row.spuSaleAttrValueList 添加之前需要判断收集到的数据是否为空，还有是否和已经存在重复
   11. 删除属性值和删除属性
       - 都不会发请求
       - 点击响应的按钮，从对应的数组当中把当前这个数据删除数组的 splice 方法
